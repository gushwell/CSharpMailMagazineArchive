┏━┳━━━━━━━━━━━━━━━━━━━━━━━━━┳━┳━┳━┓
┃☆┃ C#プログラミングレッスン            -- 入門編 -- ┃＿┃□┃×┃
┗━┻━━━━━━━━━━━━━━━━━━━━━━━━━┻━┻━┻━┛
                                                          − No.016 −
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
■演算子                                                   2004/11/27
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

これまでに、様々な演算子を紹介してきましたが、C#にはまだまだ、沢山の演
算子が用意されています。今回は、まだ、説明していない演算子について、説
明します。
いやー、それにしても、沢山の演算子がありますね。

サンプルコードも、演算子の動きを確認するのが目的なので、味気ないコード
がずらずらと続いていますが、そこはのところはご了承ください。

■──────────────────────────────────
■ 今日のサンプルコード

◆プログラムコード

  1:using System;
  2:
  3:class Program {
  4:    static void Main() {
  5:        int x = 4;
  6:        int y = 8;
  7:        Console.WriteLine(!(x == 4));
  8:        Console.WriteLine((x == 4) ^ (y == 8));
  9:        Console.WriteLine("{0:x8}", x ^ 7);
 10:        Console.WriteLine("{0:x8}, {1:x8}", x, ‾x);
 11:        Console.WriteLine("{0:x8}", x & y);
 12:        Console.WriteLine("{0:x8}", x | y);
 13:        Console.WriteLine((x == 4) && (y == 1));
 14:        Console.WriteLine((x == 4) || (y == 1));
 15:        Console.WriteLine("{0:x8}", x << 1);
 16:        Console.WriteLine("{0:x8}", x >> 1);
 17:    }
 18:}


◆実行結果

 False
 False
 00000003
 00000004, fffffffb
 00000000
 0000000c
 False
 True
 00000008
 00000002


■──────────────────────────────────
■ プログラムの解説

◆整数→16進文字列

演算子の説明をする前に、 Console.WriteLineで利用している書式について説
明します。
"{0:x8}" という文字列は、最初の 0 は、対象となるデータのインデックスを
示します。コロンはその後に書式が続くことを意味する記号です。x は、16進
文字列に変換することを示しています。最後の 8は、表示桁です。


◆ ! 演算子

!演算子は、 オペランドを否定する単項演算子です。この演算子は bool に対
して使えます。 オペランドが false の場合は true が返り、オペランドが、
true の場合は、false が返ります。

     7:        Console.WriteLine(!(x == 4));

の場合、(x == 4) の結果は、true ですから、その否定ということで、falseと
なります。


◆ ^ 演算子

^ 演算子は、 二項演算子で、整数と、bool に対して利用できます。整数の場
合は、 ビット毎の排他的ORが、計算されます。bool の場合には、オペランド
の排他的ORが計算されます。

     8:        Console.WriteLine((x == 4) ^ (y == 8));

では、true と true の排他的ORで、結果は、false となります。

     9:        Console.WriteLine("{0:x8}", x ^ 7);

は、ビット毎の排他的ORで、

      0100       // 4 の下位4ビットのみを表示
      0111       // 8 の下位4ビットのみを表示
     ------
      0011       // 結果は、3

となり、結果は、3 となります。

  ※ 排他的OR
      true  ^ true  --> false
      true  ^ false --> true
      false ^ true  --> true
      false ^ false --> false

なお、代入演算子（^=）も用意されており、
      a = a ^ b;
は
      a ^= b;
と書くことができます。


◆ ‾ 演算子

‾ 演算子では、オペランドのビットごとの補数演算が実行されます。ビットご
との補数演算子は、int、uint、long、および ulong に対して利用できます。

    10:        Console.WriteLine("{0:x8}, {1:x8}", x, ‾x);

の ‾x は、4 のビット列(下位８ビットのみ表示）は、00000100 となり、その
補数は、11111011 となり、これを１６進表示すると、fb となります。


◆ & 演算子

二項 & 演算子は、整数型と bool に対して利用できます。整数型の場合、&は
オペランドのビットごとの AND を計算します。
bool オペランドの場合は、オペランドの論理 AND が計算されます。具体的に
は、両方のオペランドが true の場合だけ結果が true になります。

    11:        Console.WriteLine("{0:x8}", x & y);

の場合、 x,y は整数ですから、 ビット毎の AND となりますので、 0100 and
1000 となり、結果は、0 となります。

なお、代入演算子（&=）も用意されており、
      a = a & b;
は
      a &= b;
と書くことができます。


◆ | 演算子

二項 | 演算子は、 整数型と bool に対して利用できます。整数型の場合、ビ
ットごとの OR が計算されます。
bool オペランドの場合は、 オペランドの論理 OR が計算されます。具体的に
は、両方のオペランドが false の場合だけ結果が false になります。

    12:        Console.WriteLine("{0:x8}", x | y);

の場合は、 x,y は整数ですので、 ビット毎の OR が計算されます。 0100 or
1000 で、1100 となり、16進表示で、c となります。

なお、代入演算子（|=）も用意されており、
      a = a | b;
は
      a |= b;
と書くことができます。


◆ &&演算子

二項 && 演算子は、bool オペランドの論理 AND が実行されます。なお、必要
な場合のみ、 2 番目のオペランドが評価されます。2番目のオペランドは評価
されない場合があります。
例えば、
    if ( a == b && a == c ) {
        ..
    }
の場合、 a == b が false の場合、a == c を評価しなくても、全体の結果が
false であることが明白であるため、a == c は評価されません。

    13:        Console.WriteLine((x == 4) && (y == 1));

では、true and false で、結果は、false となります。


◆ ||演算子

条件 || 演算子は bool オペランドの論理 OR が実行されます。なお必要な場
合だけ、2 番目のオペランドが評価されます。
例えば、
    if ( a == b || a == c ) {
      ...
    }
の場合、a == b が成り立てば、a == c を評価しなくても、全体の式が、true
であることが明白であるため、a == c は、評価されません。

    14:        Console.WriteLine((x == 4) || (y == 1));

では、true or false で、結果は trueです。なお、実際には、(y == 1)は、評
価されません。


◆ <<演算子

<< は、 左シフト演算子と呼ばれ、2 番目のオペランドで指定されたビット数
だけ最初のオペランドが左にシフトされます。

    15:        Console.WriteLine("{0:x8}", x << 1);

では、 0100 で、1 ビット左にシフトされ、1000 となり、１６進表記では、8
となります。

なお、<<= という代入演算子もあり、
    a <<= 2;
のような 書き方も可能です。


◆ >>演算子

>> は、右シフト演算子と呼ばれ、2 番目のオペランドで指定されたビット数だ
け最初のオペランドが右にシフトされます。

    16:        Console.WriteLine("{0:x8}", x >> 1);

では、0100 が右に１ビットシフトされ、0010 となり、結果は、2 となります。

<<= と同じく、>>=代入演算子も用意されています。


■──────────────────────────────────
■ 補足事項・関連事項


◆ & 演算子と &&演算子の違い

以下のコードを見てください。

  if ( a == 1 & b == 1 )
    Console.WriteLine("a,b ともに 1です");

  if ( a == 1 && b == 1 )
    Console.WriteLine("a,b ともに 1です");

この２つ結果的には、同じなのですが、微妙な違いがあります。それは、前者
(&)は、必ず b == 1 が評価されるのに対し、後者(&&)は、b == 1 が評価され
ない場合があということです。
もし、 a の値が 0 ならば、b の値が何であろうと、ifの () 内の条件は、成
り立たないので、 b == 1 を評価しなくても、false だと分かります。このた
め、b == 1 の評価は行われません。

僕の個人的た見解は、 論理演算では、& ではなく、&& を使ったほうが良いと
思いますが、一点注意すべきことがあります。それは、

  if ( a[i++] == 1 && b[j++] == 1 ) {
     ...
  }

といった副作用のあるコードを書いてはいけない、ということです。このの場
合、j++ がインクリメントされない場合が出てきてしまいます。このあたりを
理解しないまま使うと、思わぬバグが入り込む危険がありますので、注意して
ください。