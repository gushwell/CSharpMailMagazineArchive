■━ [C#プログラミングレッスン] ━━━━━━━━━━━━━━━ No.388 ━□

「アルゴリズム編」-- リンクリスト(3)
                                                           by Gushwell
□━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━■

だいぶ春らしくなってきましたが、僕は花粉症で鼻水はでるわ、くしゃみはでるわ、
頭がぼーっとしているわで、つらい日が続いています。皆さんは大丈夫ですか？

さて、またまた１週間空いてしまいましたが、今回はリンクリストの２問目に挑戦
です。


■□───────────────────────────────────
■□ 問題 （リンクリスト）

単方向連結リストにおいて、末尾から数えてk番目の要素を見つけるアルゴリズムを
実装してください。

 出展：『世界で闘うプログラミング力を鍛える150問』P-XXX
 http://www.amazon.co.jp/exec/obidos/ASIN/4839942390/gaius-22/


■□───────────────────────────────────
■□ どのように問題を解くが考える

単方向リストは、リストを逆順に辿ることができないためなんらかの工夫が必要で
すね。
順序を逆転させたリストを作り、それで先頭からN番目の要素を取り出すというのが
すぐに考え付くいちばんナイーブなやり方ですが、それだとあまりにも能がないと
いうことで、もう少し、工夫をしましょう。

作業域として用意する領域がなるべく少なくなるようにしたいです。一番最後まで
辿っていったときに、後ろからN番目の要素がどこかに記憶されていれば良い。しか
し、N番目の要素だけを覚えておくというのは難しそうです。

そこで、長さ n の配列を用意して、リストを辿るときに、直近のN個を配列に覚え
ておき、リストが最後前辿れた時に、その配列の最初の要素を返せば、よさそうで
す。
 
しかし、配列の要素をその都度シフトしていくのは非効率的です。
 
こんな時、配列をリング状に見立てて配列の最後までいったら、先頭に戻って要素
を入れていけば、要素を移動する手間がなくなります。
最後まで進んだときは、このリング状の配列の最後の要素の次にある値が求める
べき、最後からN番目の値となります。
 
うん、言葉だけで説明するのは難しいですね。
絵を使えば簡単なのですが、テキスト形式のメルマガの限界ですかね。なんとか文字だけで
頑張って説明してみたいと思います。
まずは、

 A D O K M N H Y E R Q P V C X D F

というリストがあったとします。この時、最後から６番目の値を求める時に配列
（リングバッファ）がどうなるのかを以下に示してみます。
 
単方向連結リスト  A D O K M N H Y E R Q P V C X D F
リングバッファ    A
                  A D              
                  A D O  
                  A D O K
                  A D O K M
                  A D O K M N
                    D O K M N H
                            ...
                                    R Q P V C X    
                                      Q P V C X D  
                                        P V C X D F

最後まで進んだ時のリングバッファの状態は、P V C X D F となりますので、
F の次の要素 P が求める答えとなります。


■□───────────────────────────────────
■□ コードを書く

やり方が決まったので、これをコードにしてみまたいのですが、N番目の定義を
再度しておきたいと思います。
先ほどの説明の例では、最後の要素を 1番目から数えるようにしていましたが、
0番目からにしたいと思います。
つまり、末尾から数えて０番目の要素が、連結リストの最後の要素とします。

以下がその GetLastNth<T> メソッドのコードとなります。

 static T GetLastNth<T>(SingleLinkedList<T> list, int n) {
     T[] buff = new T[++n];
     int ix = 0;
     Node<T> curr = list.Head;
     while (curr != null) {
         buff[ix % n] = curr.Value;
         ix++;
         curr = curr.Next;
     }
     if (ix < n)
         // サイズよりも大きい値を与えられた時にどうするかという問題が残る
         throw new IndexOutOfRangeException();
     return buff[ix % n];
 }

※SingleLinkedList ジェネリッククラスは前回示しましたので割愛します。

配列 buffがリングバッファになります。nよりも一つ大きいサイズで配列の
要素を確保しています。このbuff に要素を格納するときに、

         buff[ix % n] = curr.Value;

とすることで、配列のサイズをはみ出さずに、リンクリストの要素を格納していっ
ています。
ループから抜け出たら、ixは次を指していますので、

     return buff[ix % n];

で求める値を戻しています。


■□───────────────────────────────────
■□ 確認のコードを書く

では、このコードの動きを確認するコードを書いてみます。

 var list = new SingleLinkedList<string>();
 list.Append("A");
 list.Append("B");
 list.Append("C");
 list.Append("D");
 list.Append("E");
 list.Append("F");
 list.Append("G");
 for (int n = 0; n <= 6; n++) {
     var x = GetLastNth(list, n);
     Console.WriteLine(x);
 }

このコードを実行すれば、以下のような結果が得られます。

 G
 F
 E
 D
 C
 B
 A


■□───────────────────────────────────
■□ 次回の問題 （リンクリスト）

循環する連結リストが与えられたとき、循環する部分の最初のノードを返すアルゴ
リズムを実装してください。
 定義
   循環を含む連結リスト：連結リストAではループを作るために、リスト内のノー
   ドの次へのポインタが以前に出現したノードを指している。
 例 
   入力 A -> B -> C -> D -> E -> C [最初のCと同じもの]
   出力 C


  出展：『世界で闘うプログラミング力を鍛える150問』
  http://www.amazon.co.jp/exec/obidos/ASIN/4839942390/gaius-22/

─────────────────────────────────────
『C#プログラミングレッスン』  (ほぼ週刊）
☆皆さまからの感想をお待ちしています。http://gushwell.ifdef.jp/mail.html
─────────────────────────────────────
Published by Gushwell.
Copyright (C) 2014 Gushwell All rights reserved.
Microsoft MVP for Visual C#(Apr 2005 - Mar 2014)

■Gushwell's Page
facebook Page                     : http://www.facebook.com/CSharpLesson
Gushwell's C# Dev Notes           : http://gushwell.ldblog.jp/
Gushwell's C# Programming Page    : http://gushwell.ifdef.jp/
気ままな読書ノート                : http://gwbooks.hatenablog.com/
Twitterアカウント                 : @gushwell
─────────────────────────────────────
