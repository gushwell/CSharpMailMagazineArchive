■━ [C#プログラミングレッスン] ━━━━━━━━━━━━━━━ No.403 ━□

「続・アルゴリズム編」-- 再帰(2)
                                                          by Gushwell
□━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━■

今回も再帰処理の問題に挑戦です。
前回よりもすこし難易度が上がっていますが、じっくりと読んでいただければと思
います。

■□───────────────────────────────────
■□ 問題 （再帰）

n組の括弧に対し括弧の対応がとれた並び順すべてを表示するアルゴリズムを実装し
てください。

例
入力：3
出力：((())), (()()), (())(), ()(()), ()()()

 出展：『世界で闘うプログラミング力を鍛える150問』
 http://www.amazon.co.jp/exec/obidos/ASIN/4839942390/gaius-22/


■□───────────────────────────────────
■□ アルゴリズムを考える。

この手の問題を解くアルゴリズムを一瞬で閃くという人はいるのでしょうか？
僕は残念ながらまったく閃きません(笑)。

問題を解く取っ掛かりをつかむために今回も具体的な例で考えて見ます。
ある文字列領域に、'(' ')' を追加しいていく処理になりますので、求める並び順
を表す文字列は、 " " で括ることとします。

※ この具体的な例については、文章を「である調」に変えます。

●入力 : 1 の場合

( を 置くと、 残りは ')' だけなので、 "()" となる。


●入力 ：2の場合

( を置く、残りは、 '(' が１つと  ')' が２つだから、

 "(("  -- #1
 "()"  -- #2

という２つの並び順の可能性がある。これをそれぞれ、#1,#2とすると、#1の場合、
')' だけが残っているので、 "(())" となる。

#2の場合は、'(' と ')' がひとつずつ残っている。この時、"())" という並びは許
されないので、"()()" の１種類である。
つまり、
 "(())"
 "()()"
の２つということになる。

●入力 : 3 の場合

さらに入力３の時について考えていく。

やはり最初は、

 "(("     --- #1
 "()"     --- #2

の２つの並びが存在する。説明の便宜上、先ほどと同様に、#1, #2 というIDを振っ
ておこう。

まずは、#1 の "((" のときだけ考える。残りは、'(' ひとつ、 ')' が３つだから、
次に得られるのは、

 "((("    --- #11
 "(()"    --- #12

の２種類である。
#11だけみると、残りは、')' が３つなので、

 "((()))"  --- #111

の１種類となる。

#12についてみると '(' が残り１つ、')' が残り２つだから、

 "(()("    --- #121
 "(())"    --- #122

が組み立てられる。
#121 から生成されるのは 

 "(()())"  

ひとつだ。
#122 から生成されるのは、やはり

 "(())()" 

のひとつとなる。

こうやっていけば、括弧の対応がとれた並び順すべてを表示することができそうだ。

以下に、この文字列が組み立てられる様子を図で表してみた。

( +-- (( +-- ((( --- ((() --- ((()) --- ((()))
 |      |
 |      +-- (() +-- (()( --- (()() --- (()())
 |              |
 |              +-- (()) --- (())( --- (())()
 |
 +-- () +-- ()( +-- ()(( --- ()(() --- ()(())
                |
                +-- ()() --- ()()( --- ()()()



ここで、注目するのは３つだ。

1. 処理経過がTree上に表せるということだ。つまり、Tree上に表せるということは
  再帰が向いているということになる。

2. この枝の分岐は２つ以下ということ。

3. '(' と ')' の残り数が問題を解くカギになる。
  '(' が残っていれば、'(' はいつでも、現在組み立てている文字列に追加できる。
  つまり、それぞれの残数を L, R とすれば、0 < L のときは追加できるというこ
  とだ。
  一方 ')' は 対応する '(' が現在の組み立てている文字列にあれば ')'を追加
  できる。つまり、L < R ならば、追加できるということになる。
  ということは、
   1. 現在組み立てている文字列 S 
   2. '(' の残数 L 
   3. ')' の残数 R 
  の３つを管理すれば、すべての並び順を求めていくことができる。


■□───────────────────────────────────
■□ 実装する


これでやっとコードを書ける準備が整ったようです。(「ですます調」に戻します)
すべての並び順を表示するメソッドを f と命名すると、f(S,L,R) を定義すればよ
いということです。
入力=2 の場合を考えます。
最初は、

 f("", 2, 2)

を呼び出すことになりますね。
処理が少し進んで、現在の S が "(" の時には、L=1, R=2 なので、

  f(S+"(", L-1, R)   -- つまり f("((", 0, 2)

と

  f(S+")", L, R-1)   -- つまり f("()", 1, 1)

を呼び出せば、並び順を表示することができるはずです。つまり、ここで処理が２
つに分岐するということですね。
これを繰り返し、引数の L と R が 0 になったら、引き数 Sが求める答えというこ
とになります。

では、実際のコードをお見せしましょう。

class Solver {
    public void Exec(int n) {
        MakeParenthesisString("", n, n);

    }

    // s : 組み立て途中の文字列
    // left : ( の 残りの数
    // right : ) の 残りの数
    public static void  MakeParenthesisString(string s, int left, int right) {
        if (left == 0 && right == 0) {
            // 求まった文字列を表示する。
            Console.WriteLine(s);
            return;
        }
        if (left > 0) {
            // まだ ( が残っていれば、 ( を 加える。
            MakeParenthesisString(s + "(", left - 1, right);
        }
        if (left < right) {
            // 対応する （ が 文字列に加えられているならば、
            // ) を加えることができる。
            MakeParenthesisString(s + ")", left, right - 1);
        }
    }
}

class Program {
    static void Main(string[] args) {
        Solver sol = new Solver();;
        sol.Exec(3);    // n = 3 の時の文字列を列挙する
        sol.Exec(5);    // n = 5 の時の文字列を列挙する
        }
    }
}

先ほど、「繰り返し」という用語を使いましたが、ループのコードは表れません。
関数の中で、自分自身の関数を呼び出すことで、繰り返しを表しています。
これを再帰と言います。
ただ、自分自身を呼び出し続けては、いつまでたっても終わりませんので、自分自
身を呼び出さずに関数から抜けるルートもきとんと用意しておく必要があります。
上のコードでは、(left == 0 && right == 0) が成立した場合は、自分自身を呼び
出さずに、関数から抜けていますので、無限ループに陥ることはありません。


■□───────────────────────────────────
■□ コードを改良する。

これで、問題の要件を満たしたコードとなりましたが、MakeParenthesisStringで、
コンソールに表示してしまうのは、あまり気持ちよいものではありません。

やはり、答えを見つけるメソッドと、答えを表示するメソッドは分けたいですよね。

ということで、さらに改良してみました。

再帰メソッドの中で、ある値のシーケンスを戻したいときの良いサンプルコードに
なっていると思います。yield return を使うのがキーポイントです。
Solverクラスの中では、Console.WriteLineなどの出力メソッドが無いことに注目し
てください。

class Solver {
    public IEnumerable<string> Exec(int n) {
        return MakeParenthesisString("", n, n);
    }

    // s : 組み立て途中の文字列
    // left : ( の 残りの数
    // right : ) の 残りの数
    public IEnumerable<string> MakeParenthesisString(string s, int left, int right) {
        if (left == 0 && right == 0) {
            yield return s;
        }
        if (left > 0) {
            // まだ ( が残っていれば、 ( を 加える。
            var q = MakeParenthesisString(s + "(", left - 1, right);
            foreach (var x in q)
                yield return x;
        }
        if (left < right) {
            // 対応する （ が 文字列に加えられているならば、 ) を
            // 加えることができる。
            var q = MakeParenthesisString(s + ")", left, right - 1);
            foreach (var x in q)
                yield return x;
        }
    }
}

class Program {
    static void Main(string[] args) {
        Solver sol = new Solver();
        // n=1,2,3,4,5で確認してみる。
        for (int n = 1; n <= 5; n++) {
            sol.Exec(n).ToList().ForEach(Console.WriteLine);
            Console.ReadLine();
        }
    }
}



-------------------------------------------------------------------------

再帰処理の問題が２問続きましたが、これで、再帰処理の理解も随分と深まったの
ではと思います。

次回は、データ構造の学習では避けて通ることのできない木構造の問題に挑戦しま
す。再帰処理がここでも大活躍の予定です。

─────────────────────────────────────
『C#プログラミングレッスン』  (ほぼ週刊）
☆皆さまからの感想をお待ちしています。http://gushwell.ifdef.jp/mail.html
─────────────────────────────────────
Published by Gushwell.
Copyright (C) 2014 Gushwell All rights reserved.
Microsoft MVP for Visual C#(Apr 2005 - Mar 2015)

■Gushwell's Page
facebook Page                     : http://www.facebook.com/CSharpLesson
Gushwell's C# Dev Notes           : http://gushwell.ldblog.jp/
Gushwell's C# Programming Page    : http://gushwell.ifdef.jp/
気ままな読書ノート                : http://gwbooks.hatenablog.com/
Twitterアカウント                 : @gushwell
─────────────────────────────────────
