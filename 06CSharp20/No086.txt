┏━┳━━━━━━━━━━━━━━━━━━━━━━━━━┳━┳━┳━┓
┃☆┃ C#プログラミングレッスン                         ┃＿┃□┃×┃
┣━┻━━━━━━━━━━━━━━━━━━━━━━━━━┻━┻━┻━┫
┃Generics(1) ジェネリック ジェネリッククラスの利用           No.086┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

今回から、C#2.0で新たに追加された機能について解説します。

読者の方の中には、まだ、VS2003を利用されている方も多いと思いますが、
マイクロソフト社から無償で提供されている「Visual C# 2005 Express 
Edition」を使えば、C#2.0の機能を試すことができますので、VS2005をお持ち
で無い場合は、是非この機会に「Visual C# 2005 Express Edition」をダウン
ロードされつことをお勧めします。
無償版ではありますが、びっくりするくらい良くできた製品です。

まずは、もっとも重要な機能追加だと思われるジェネリックです。

■──────────────────────────────────
■ ジェネリックを使用しない場合の問題点

複数のオブジェクトを管理するコレクションクラスArrayListは、 object型を
使用して任意の型を格納できるため、柔軟性がありとても便利なクラスです。
しかし、以下のような欠点もあります。

・取り出す際に、キャストが必要。かつ、キャストの型を間違ってもコンパイ
  ルエラーにならない。
・間違った型のインスタンスを追加してもエラーにならない。
・値型を格納する場合、boxing、unboxingが発生。

ArrayListを使った以下のコードで、1つずつ見ていきましょう。

  1: using System.Collections;
  2: ...
  3:
  4:   ArrayList list = new ArrayList();
  5:   list.Add( new MyStruct(10) );
  6:   list.Add( new MyStruct(20) );
  7:
  8:   MyStruct x = (MyStruct)list[0];
  9:   MyStruct y = (MyStruct)list[1];

  ※ MyStructは定義済みの構造体とします。

●取り出す際に、キャストが必要。

ArrayListに格納したオブジェクトを取り出す際は、 必ず該当する型にキャス
トしないといけません。

  MyStruct x = list[0];

のように記述すると、コンパイルエラーになります。
また、キャストの型を間違ってもコンパイルエラーになりません。

  string s = (string)list[0];

のようなコードを書いても、コンパイル時にはエラーにならないため、間違い
の発見が遅れることになります。

●間違った型のインスタンスを追加してもエラーにならない。

list変数は、MyStruct型だけを格納する目的で宣言した変数ですが、

  list.Add( 10 );

のように、別の型を追加しても、エラーになりません。（これは、利点でもあ
るのですが...）
コンパイルエラーだけではなく、実行時にもエラーになりません。
もちろん、取り出す際に型が違うので例外が発生しますが、このようなエラー
は、エラー箇所の特定に時間がかかってしまいます。

●値型の場合、boxing、unboxingが発生

ArrayListに値型のオブジェクトを格納する場合は、 boxing, unboxingが発生
します。大量のデータを扱う場合、パフォーマンスの低下が起こる危険があり
ます。


■──────────────────────────────────
■ ジェネリック

このように、ArrayListは便利ですが欠点もあります。これらの欠点を解消した
ArrayListがあれば、便利ですよね。
C#2.0で導入された、ジェネリックを使用するとこれが可能になります。

それでは、ジェネリックの機能を使ったコードを見てみましょう。

  using System.Collections.Generic;
  ...
  List<MyStruct> list = new List<MyStruct>();
  list.Add( new MyStruct(10) );
  list.Add( new MyStruct(２0) );

  MyStruct x = list[0];
  MyStruct y = list[1];

System.Collections.Generic は、.NET Framework2.0で新たに追加された名前
空間です。ここに、Listという新しいジェネリッククラスが用意されています。

List<MyStruct>で、MyStructだけが格納される List であることを宣言してい
ます。
面倒ですが、new する際にも、new List<MyStruct>()と、その型を指定してい
ます。

  -------------------------------------------------------------------
   MyStructではなく、int型を格納したい場合は、以下のように記述します。

     List<int> list = new List<int>();

   stringを格納したい場合は、

     List<string> list = new List<string>();

   です。
  -------------------------------------------------------------------

データを格納する時のコードは、ArrayListと同じですが、

  list.Add( 10 );

と書くと、コンパイルエラーとなり、MyStruct以外のオブジェクトを追加する
ことはできません。

Listに格納されたオブジェクトを取り出す際は、

  MyStruct x = list[0];

と、キャストすることなく、取り出すことができます。
当然、

  int x = list[0];

のような間違ったコードを書くと、コンパイルエラーになります。

このように、 ArrayListでは、コーディングの間違いが、実行時でないと分か
らなかったのが、ジェネリックを使うことで、コンパイル時にエラーを検出で
きるようになります。
また、この際、boxingも発生しませんので、パフォーマンスの低下を気にする
必要もありません。

■──────────────────────────────────
■ < > 内で指定できる型

今回は、MyStructという構造体を例に説明しましたが、< > の中には、classや
interface, 列挙型を指定することもできます。
クラスを指定した場合は、指定したクラスとその子孫クラスのオブジェクトだ
けが、格納できるようになります。

また、

  List<List<int>> list = new List<List<int>>();

のように、< > の中に、ジェネリックを使った型を指定することもできます。

┌─┬─────────────────────────┬─┬─┬─┐
│☆│ C#プログラミングレッスン  (ぼぼ週刊）            │＿│□│×│
├─┴─────────────────────────┴─┴─┴─┤
│ Published by Gushwell.                                           │
│ Copyright (C) 2004-2006 Gushwell All rights reserved.            │
│ Microsoft MVP Visual Developer - Visual C#(Apr 2006 - Mar 2006)  │
│-------------------- Gushwell's Page ---------------------------- │
│ 窓際プログラマーの独り言  ：http://blog.livedoor.jp/gushwell/    │
│ 窓際プログラマーの読書三昧：http://gushwell.jugem.jp/            │
│             よろしかったらアクセスしてみてください！             │
└─────────────────────────────────┘
