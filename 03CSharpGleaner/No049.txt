┏━┳━━━━━━━━━━━━━━━━━━━━━━━━━┳━┳━┳━┓
┃☆┃ C#プログラミングレッスン                         ┃＿┃□┃×┃
┣━┻━━━━━━━━━━━━━━━━━━━━━━━━━┻━┻━┻━┫
┃デストラクタ                                               No.049 ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

■──────────────────────────────────
■ デストラクタとは

デストラクタとは、インスタンスが破棄される時に呼び出される特殊なメソッ
ドです。コンストラクタはインスタンスが生成される時に呼び出されるメソッ
ドですが、デストラクタはその対になるものです。
デストラクタの書き方は

  ~クラス名() {
      ...
  }

となり、クラスの名前の前に、~ （チルダ）を付けたものになります。デスト
ラクタは、戻り値はありません。

デストラクタの中には、インスタンスが破棄される前に何か処理をしたいとき
に使います。
こんな感じですね。

  class MyClass {
      public MyClass() {
          // 初期化
      }
      ~MyClass() {
          // 後処理
      }
  }


■──────────────────────────────────
■ デストラクタの問題点

しかし、このようなコードは、Ｃ＃ではあまり使われることはありません。そ
れは、C#（.NET）では、インスタンスの破棄のタイミングをプログラマが明示
的に指定できないからです。
インスタンスの破棄は、.NETのガベージコレクションが自動的に行ってくれま
す。 そのため、C++のような言語と異なり、インスタンスを破棄するコードを
プログラマが書く必要がありません。これは、メモリリークという厄介な問題
から、プログラマを解放してくれるとても素晴らしい機能なのですが、光があ
れば陰があるように、このガベージコレクションにも落とし穴があります。

それは、以下のようなコードを想像してもらえれば良いでしょう。

  class MyStream {
      public MyStream(string filename) {
          // ここでファイルをオープン
      }
      ~MyStream() {
          // ここでファイルをクローズ
      }
  }


このクラスでは、コンストラクタで、ファイルをオープンし、デストラクタで
ファイルをクローズしています。 この MyStream は１回しか new されないの
ならば、 問題は出ませんが、同じファイル名に対し、複数回 new されると問
題が発生してしまいます。
それは、ファイルをクローズしないまま、同じファイルをオープンすることに
なるからです。C++ のように、

    MyStream st = new MyStream(filename);
    // ここで処理をする
    delete st;    // インスタンスを破棄 (デストラクタを呼び出す）

と書ければ、デストラクタの呼び出しタイミングを制御できますが、C#では、
デストラクタの呼び出しは、.NET側が管理していますので、プログラマはデス
トラクタの呼び出しタイミングを制御することができません。


■──────────────────────────────────
■ Disposeメソッド

.NETでは、この問題を回避するために、上記のような場合には、デストラクタ
に後処理を書くのではなく、Dispose メソッドに後処理を書き、このクラスを
利用する側が明示的に Dispose メソッドを呼ぶようにすることが、 推奨され
ています。

  class MyStream : IDisposable {
      public MyStream(string filename) {
          // ここでファイルをオープン
      }
      public void Dispose() {
          // ここでファイルをクローズ
      }
  }


とすれば、以下のように、明示的にファイルをクローズさせることができます。

    MyStream st = new MyStream(filename);
    try {
        // ここで処理をする
    } finally {
        st.Dispose();    // ファイルをクローズする
    }

usingステートメントを使えば、もっと簡単に上記と同じことができます。

    using( MyStream st = new MyStream(filename) ) {
       // ここで処理をする
    }

なお、実際に、Dispose メソッドを実装する場合には、もう少し複雑なコード
を書く必要があります。 興味のある方は .NETのドキュメントを読んでみてく
ださい。

┌─┬─────────────────────────┬─┬─┬─┐
│☆│ C#プログラミングレッスン  (ぼぼ週刊）            │＿│□│×│
├─┴─────────────────────────┴─┴─┴─┤
│ Published by Gushwell  (Microsoft MVP for Visual C#)             │
│ Copyright (C) 2004-2005 Gushwell All rights reserved.            │
│-------------------- Gushwell's Page ---------------------------- │
│ 窓際プログラマーの独り言  ：http://blog.livedoor.jp/gushwell/    │
│ 窓際プログラマーの読書三昧：http://gushwell.jugem.jp/            │
│             よろしかったらアクセスしてみてください！             │
└─────────────────────────────────┘

